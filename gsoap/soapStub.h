/* soapStub.h
   Generated by gSOAP 2.8.45 for InterfaceToFace.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_ns2	"http://tempuri.org/Imports"
#define SOAP_NAMESPACE_OF_ns1	"http://tempuri.org/"
#define SOAP_NAMESPACE_OF_ns3	"http://schemas.microsoft.com/2003/10/Serialization/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20845
# error "GSOAP VERSION 20845 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* InterfaceToFace.h:153 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (14)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__anyType;	/* InterfaceToFace.h:150 */
class xsd__base64Binary;	/* InterfaceToFace.h:156 */
class xsd__ID_;	/* InterfaceToFace.h:174 */
class xsd__IDREF_;	/* InterfaceToFace.h:184 */
class xsd__QName_;	/* InterfaceToFace.h:191 */
class xsd__anyURI_;	/* InterfaceToFace.h:201 */
class xsd__base64Binary_;	/* InterfaceToFace.h:208 */
class xsd__boolean;	/* InterfaceToFace.h:215 */
class xsd__byte_;	/* InterfaceToFace.h:222 */
class xsd__dateTime;	/* InterfaceToFace.h:229 */
class xsd__decimal_;	/* InterfaceToFace.h:239 */
class xsd__double;	/* InterfaceToFace.h:246 */
class xsd__duration_;	/* InterfaceToFace.h:256 */
class xsd__float;	/* InterfaceToFace.h:263 */
class xsd__int;	/* InterfaceToFace.h:270 */
class xsd__long;	/* InterfaceToFace.h:277 */
class xsd__short;	/* InterfaceToFace.h:284 */
class xsd__string;	/* InterfaceToFace.h:291 */
class xsd__unsignedByte_;	/* InterfaceToFace.h:298 */
class xsd__unsignedInt;	/* InterfaceToFace.h:305 */
class xsd__unsignedLong;	/* InterfaceToFace.h:312 */
class xsd__unsignedShort;	/* InterfaceToFace.h:319 */
class ns3__char__;	/* InterfaceToFace.h:368 */
class ns3__duration__;	/* InterfaceToFace.h:381 */
class ns3__guid__;	/* InterfaceToFace.h:393 */
class _ns1__FaceService;	/* InterfaceToFace.h:333 */
class _ns1__FaceServiceResponse;	/* InterfaceToFace.h:336 */
struct __ns1__FaceService;	/* InterfaceToFace.h:714 */

/* InterfaceToFace.h:150 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (11)
/* Type xsd__anyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW(xsd__anyType); }
      public:
        /// Constructor with initializations
        xsd__anyType()
        {
          __item = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:156 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (15)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary()
        {
          __ptr = (unsigned char *)0;
          __size = 0;
          id = NULL;
          type = (char *)0;
          options = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:174 */
#ifndef SOAP_TYPE_xsd__ID_
#define SOAP_TYPE_xsd__ID_ (23)
/* Type xsd__ID_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:ID': */
class SOAP_CMAC xsd__ID_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:ID' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__ID_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__ID_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__ID_, default initialized and not managed by a soap context
        virtual xsd__ID_ *soap_alloc(void) const { return SOAP_NEW(xsd__ID_); }
      public:
        /// Constructor with initializations
        xsd__ID_()
        {
        }
        virtual ~xsd__ID_() { }
        /// Friend allocator used by soap_new_xsd__ID_(struct soap*, int)
        friend SOAP_FMAC1 xsd__ID_ * SOAP_FMAC2 soap_instantiate_xsd__ID_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:184 */
#ifndef SOAP_TYPE_xsd__IDREF_
#define SOAP_TYPE_xsd__IDREF_ (25)
/* Type xsd__IDREF_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:IDREF': */
class SOAP_CMAC xsd__IDREF_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:IDREF' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__IDREF_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__IDREF_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__IDREF_, default initialized and not managed by a soap context
        virtual xsd__IDREF_ *soap_alloc(void) const { return SOAP_NEW(xsd__IDREF_); }
      public:
        /// Constructor with initializations
        xsd__IDREF_()
        {
        }
        virtual ~xsd__IDREF_() { }
        /// Friend allocator used by soap_new_xsd__IDREF_(struct soap*, int)
        friend SOAP_FMAC1 xsd__IDREF_ * SOAP_FMAC2 soap_instantiate_xsd__IDREF_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:191 */
#ifndef SOAP_TYPE_xsd__QName_
#define SOAP_TYPE_xsd__QName_ (26)
/* Type xsd__QName_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:QName': */
class SOAP_CMAC xsd__QName_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:QName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__QName_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__QName_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__QName_, default initialized and not managed by a soap context
        virtual xsd__QName_ *soap_alloc(void) const { return SOAP_NEW(xsd__QName_); }
      public:
        /// Constructor with initializations
        xsd__QName_()
        {
        }
        virtual ~xsd__QName_() { }
        /// Friend allocator used by soap_new_xsd__QName_(struct soap*, int)
        friend SOAP_FMAC1 xsd__QName_ * SOAP_FMAC2 soap_instantiate_xsd__QName_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:201 */
#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (28)
/* Type xsd__anyURI_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyURI': */
class SOAP_CMAC xsd__anyURI_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyURI' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyURI_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__anyURI_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyURI_, default initialized and not managed by a soap context
        virtual xsd__anyURI_ *soap_alloc(void) const { return SOAP_NEW(xsd__anyURI_); }
      public:
        /// Constructor with initializations
        xsd__anyURI_()
        {
        }
        virtual ~xsd__anyURI_() { }
        /// Friend allocator used by soap_new_xsd__anyURI_(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyURI_ * SOAP_FMAC2 soap_instantiate_xsd__anyURI_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:208 */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (29)
/* Type xsd__base64Binary_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:base64Binary': */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary_, default initialized and not managed by a soap context
        virtual xsd__base64Binary_ *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary_); }
      public:
        /// Constructor with initializations
        xsd__base64Binary_()
        {
        }
        virtual ~xsd__base64Binary_() { }
        /// Friend allocator used by soap_new_xsd__base64Binary_(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary_ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:215 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (30)
/* Type xsd__boolean is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:boolean': */
class SOAP_CMAC xsd__boolean : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__boolean; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean, default initialized and not managed by a soap context
        virtual xsd__boolean *soap_alloc(void) const { return SOAP_NEW(xsd__boolean); }
      public:
        /// Constructor with initializations
        xsd__boolean()
        {
          __item = (bool)0;
        }
        virtual ~xsd__boolean() { }
        /// Friend allocator used by soap_new_xsd__boolean(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:222 */
#ifndef SOAP_TYPE_xsd__byte_
#define SOAP_TYPE_xsd__byte_ (32)
/* Type xsd__byte_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:byte': */
class SOAP_CMAC xsd__byte_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:byte' wrapped by this struct
        char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__byte_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__byte_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__byte_, default initialized and not managed by a soap context
        virtual xsd__byte_ *soap_alloc(void) const { return SOAP_NEW(xsd__byte_); }
      public:
        /// Constructor with initializations
        xsd__byte_()
        {
          __item = (char)0;
        }
        virtual ~xsd__byte_() { }
        /// Friend allocator used by soap_new_xsd__byte_(struct soap*, int)
        friend SOAP_FMAC1 xsd__byte_ * SOAP_FMAC2 soap_instantiate_xsd__byte_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:229 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (33)
/* Type xsd__dateTime is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:dateTime': */
class SOAP_CMAC xsd__dateTime : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__dateTime
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__dateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime, default initialized and not managed by a soap context
        virtual xsd__dateTime *soap_alloc(void) const { return SOAP_NEW(xsd__dateTime); }
      public:
        /// Constructor with initializations
        xsd__dateTime()
        {
          __item = (time_t)0;
        }
        virtual ~xsd__dateTime() { }
        /// Friend allocator used by soap_new_xsd__dateTime(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:239 */
#ifndef SOAP_TYPE_xsd__decimal_
#define SOAP_TYPE_xsd__decimal_ (36)
/* Type xsd__decimal_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:decimal': */
class SOAP_CMAC xsd__decimal_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:decimal' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__decimal_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__decimal_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__decimal_, default initialized and not managed by a soap context
        virtual xsd__decimal_ *soap_alloc(void) const { return SOAP_NEW(xsd__decimal_); }
      public:
        /// Constructor with initializations
        xsd__decimal_()
        {
        }
        virtual ~xsd__decimal_() { }
        /// Friend allocator used by soap_new_xsd__decimal_(struct soap*, int)
        friend SOAP_FMAC1 xsd__decimal_ * SOAP_FMAC2 soap_instantiate_xsd__decimal_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:246 */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (37)
/* Type xsd__double is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:double': */
class SOAP_CMAC xsd__double : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:double' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__double
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__double; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__double, default initialized and not managed by a soap context
        virtual xsd__double *soap_alloc(void) const { return SOAP_NEW(xsd__double); }
      public:
        /// Constructor with initializations
        xsd__double()
        {
          __item = (double)0;
        }
        virtual ~xsd__double() { }
        /// Friend allocator used by soap_new_xsd__double(struct soap*, int)
        friend SOAP_FMAC1 xsd__double * SOAP_FMAC2 soap_instantiate_xsd__double(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:256 */
#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (40)
/* Type xsd__duration_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:duration': */
class SOAP_CMAC xsd__duration_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:duration' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__duration_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__duration_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__duration_, default initialized and not managed by a soap context
        virtual xsd__duration_ *soap_alloc(void) const { return SOAP_NEW(xsd__duration_); }
      public:
        /// Constructor with initializations
        xsd__duration_()
        {
        }
        virtual ~xsd__duration_() { }
        /// Friend allocator used by soap_new_xsd__duration_(struct soap*, int)
        friend SOAP_FMAC1 xsd__duration_ * SOAP_FMAC2 soap_instantiate_xsd__duration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:263 */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (41)
/* Type xsd__float is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:float': */
class SOAP_CMAC xsd__float : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:float' wrapped by this struct
        float __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__float
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__float; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__float, default initialized and not managed by a soap context
        virtual xsd__float *soap_alloc(void) const { return SOAP_NEW(xsd__float); }
      public:
        /// Constructor with initializations
        xsd__float()
        {
          __item = (float)0;
        }
        virtual ~xsd__float() { }
        /// Friend allocator used by soap_new_xsd__float(struct soap*, int)
        friend SOAP_FMAC1 xsd__float * SOAP_FMAC2 soap_instantiate_xsd__float(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:270 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (43)
/* Type xsd__int is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:int': */
class SOAP_CMAC xsd__int : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__int
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__int; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int, default initialized and not managed by a soap context
        virtual xsd__int *soap_alloc(void) const { return SOAP_NEW(xsd__int); }
      public:
        /// Constructor with initializations
        xsd__int()
        {
          __item = (int)0;
        }
        virtual ~xsd__int() { }
        /// Friend allocator used by soap_new_xsd__int(struct soap*, int)
        friend SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:277 */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (44)
/* Type xsd__long is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:long': */
class SOAP_CMAC xsd__long : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:long' wrapped by this struct
        LONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__long
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__long; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__long, default initialized and not managed by a soap context
        virtual xsd__long *soap_alloc(void) const { return SOAP_NEW(xsd__long); }
      public:
        /// Constructor with initializations
        xsd__long()
        {
          __item = (LONG64)0;
        }
        virtual ~xsd__long() { }
        /// Friend allocator used by soap_new_xsd__long(struct soap*, int)
        friend SOAP_FMAC1 xsd__long * SOAP_FMAC2 soap_instantiate_xsd__long(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:284 */
#ifndef SOAP_TYPE_xsd__short
#define SOAP_TYPE_xsd__short (46)
/* Type xsd__short is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:short': */
class SOAP_CMAC xsd__short : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:short' wrapped by this struct
        short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__short
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__short; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__short, default initialized and not managed by a soap context
        virtual xsd__short *soap_alloc(void) const { return SOAP_NEW(xsd__short); }
      public:
        /// Constructor with initializations
        xsd__short()
        {
          __item = (short)0;
        }
        virtual ~xsd__short() { }
        /// Friend allocator used by soap_new_xsd__short(struct soap*, int)
        friend SOAP_FMAC1 xsd__short * SOAP_FMAC2 soap_instantiate_xsd__short(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:291 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (48)
/* Type xsd__string is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:string': */
class SOAP_CMAC xsd__string : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__string; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string, default initialized and not managed by a soap context
        virtual xsd__string *soap_alloc(void) const { return SOAP_NEW(xsd__string); }
      public:
        /// Constructor with initializations
        xsd__string()
        {
        }
        virtual ~xsd__string() { }
        /// Friend allocator used by soap_new_xsd__string(struct soap*, int)
        friend SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:298 */
#ifndef SOAP_TYPE_xsd__unsignedByte_
#define SOAP_TYPE_xsd__unsignedByte_ (49)
/* Type xsd__unsignedByte_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedByte': */
class SOAP_CMAC xsd__unsignedByte_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedByte' wrapped by this struct
        unsigned char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedByte_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedByte_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedByte_, default initialized and not managed by a soap context
        virtual xsd__unsignedByte_ *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedByte_); }
      public:
        /// Constructor with initializations
        xsd__unsignedByte_()
        {
          __item = (unsigned char)0;
        }
        virtual ~xsd__unsignedByte_() { }
        /// Friend allocator used by soap_new_xsd__unsignedByte_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedByte_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedByte_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:305 */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (50)
/* Type xsd__unsignedInt is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedInt': */
class SOAP_CMAC xsd__unsignedInt : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedInt' wrapped by this struct
        unsigned int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedInt
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedInt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedInt, default initialized and not managed by a soap context
        virtual xsd__unsignedInt *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedInt); }
      public:
        /// Constructor with initializations
        xsd__unsignedInt()
        {
          __item = (unsigned int)0;
        }
        virtual ~xsd__unsignedInt() { }
        /// Friend allocator used by soap_new_xsd__unsignedInt(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedInt * SOAP_FMAC2 soap_instantiate_xsd__unsignedInt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:312 */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (51)
/* Type xsd__unsignedLong is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedLong': */
class SOAP_CMAC xsd__unsignedLong : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedLong' wrapped by this struct
        ULONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedLong
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedLong; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedLong, default initialized and not managed by a soap context
        virtual xsd__unsignedLong *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedLong); }
      public:
        /// Constructor with initializations
        xsd__unsignedLong()
        {
          __item = (ULONG64)0;
        }
        virtual ~xsd__unsignedLong() { }
        /// Friend allocator used by soap_new_xsd__unsignedLong(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedLong * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:319 */
#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (53)
/* Type xsd__unsignedShort is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedShort': */
class SOAP_CMAC xsd__unsignedShort : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedShort' wrapped by this struct
        unsigned short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedShort
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedShort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedShort, default initialized and not managed by a soap context
        virtual xsd__unsignedShort *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedShort); }
      public:
        /// Constructor with initializations
        xsd__unsignedShort()
        {
          __item = (unsigned short)0;
        }
        virtual ~xsd__unsignedShort() { }
        /// Friend allocator used by soap_new_xsd__unsignedShort(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedShort * SOAP_FMAC2 soap_instantiate_xsd__unsignedShort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:368 */
#ifndef SOAP_TYPE_ns3__char__
#define SOAP_TYPE_ns3__char__ (58)
/* Type ns3__char__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns3:char': */
class SOAP_CMAC ns3__char__ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns3:char' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_ns3__char__
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__char__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__char__, default initialized and not managed by a soap context
        virtual ns3__char__ *soap_alloc(void) const { return SOAP_NEW(ns3__char__); }
      public:
        /// Constructor with initializations
        ns3__char__()
        {
          __item = (int)0;
        }
        virtual ~ns3__char__() { }
        /// Friend allocator used by soap_new_ns3__char__(struct soap*, int)
        friend SOAP_FMAC1 ns3__char__ * SOAP_FMAC2 soap_instantiate_ns3__char__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:381 */
#ifndef SOAP_TYPE_ns3__duration__
#define SOAP_TYPE_ns3__duration__ (60)
/* Type ns3__duration__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns3:duration': */
class SOAP_CMAC ns3__duration__ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns3:duration' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_ns3__duration__
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__duration__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__duration__, default initialized and not managed by a soap context
        virtual ns3__duration__ *soap_alloc(void) const { return SOAP_NEW(ns3__duration__); }
      public:
        /// Constructor with initializations
        ns3__duration__()
        {
        }
        virtual ~ns3__duration__() { }
        /// Friend allocator used by soap_new_ns3__duration__(struct soap*, int)
        friend SOAP_FMAC1 ns3__duration__ * SOAP_FMAC2 soap_instantiate_ns3__duration__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:393 */
#ifndef SOAP_TYPE_ns3__guid__
#define SOAP_TYPE_ns3__guid__ (62)
/* Type ns3__guid__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns3:guid': */
class SOAP_CMAC ns3__guid__ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns3:guid' wrapped by this struct
        std::wstring __item;
      public:
        /// Return unique type id SOAP_TYPE_ns3__guid__
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__guid__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__guid__, default initialized and not managed by a soap context
        virtual ns3__guid__ *soap_alloc(void) const { return SOAP_NEW(ns3__guid__); }
      public:
        /// Constructor with initializations
        ns3__guid__()
        {
        }
        virtual ~ns3__guid__() { }
        /// Friend allocator used by soap_new_ns3__guid__(struct soap*, int)
        friend SOAP_FMAC1 ns3__guid__ * SOAP_FMAC2 soap_instantiate_ns3__guid__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:333 */
#ifndef SOAP_TYPE__ns1__FaceService
#define SOAP_TYPE__ns1__FaceService (55)
/* complex XSD type 'ns1:FaceService': */
class SOAP_CMAC _ns1__FaceService {
      public:
        /// Optional element 'ns1:type' of XSD type 'xsd:string'
        wchar_t *type;
        /// Optional element 'ns1:json' of XSD type 'xsd:string'
        wchar_t *json;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__FaceService
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__FaceService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__FaceService, default initialized and not managed by a soap context
        virtual _ns1__FaceService *soap_alloc(void) const { return SOAP_NEW(_ns1__FaceService); }
      public:
        /// Constructor with initializations
        _ns1__FaceService()
        {
          type = (wchar_t *)0;
          json = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__FaceService() { }
        /// Friend allocator used by soap_new__ns1__FaceService(struct soap*, int)
        friend SOAP_FMAC1 _ns1__FaceService * SOAP_FMAC2 soap_instantiate__ns1__FaceService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:336 */
#ifndef SOAP_TYPE__ns1__FaceServiceResponse
#define SOAP_TYPE__ns1__FaceServiceResponse (56)
/* complex XSD type 'ns1:FaceServiceResponse': */
class SOAP_CMAC _ns1__FaceServiceResponse {
      public:
        /// Optional element 'ns1:FaceServiceResult' of XSD type 'xsd:string'
        wchar_t *FaceServiceResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__FaceServiceResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__FaceServiceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__FaceServiceResponse, default initialized and not managed by a soap context
        virtual _ns1__FaceServiceResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__FaceServiceResponse); }
      public:
        /// Constructor with initializations
        _ns1__FaceServiceResponse()
        {
          FaceServiceResult = (wchar_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__FaceServiceResponse() { }
        /// Friend allocator used by soap_new__ns1__FaceServiceResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__FaceServiceResponse * SOAP_FMAC2 soap_instantiate__ns1__FaceServiceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:714 */
#ifndef SOAP_TYPE___ns1__FaceService
#define SOAP_TYPE___ns1__FaceService (68)
/* Wrapper: */
struct SOAP_CMAC __ns1__FaceService {
      public:
        /** Optional element 'ns1:FaceService' of XSD type 'ns1:FaceService' */
        _ns1__FaceService *ns1__FaceService;
      public:
        /** Return unique type id SOAP_TYPE___ns1__FaceService */
        int soap_type() const { return SOAP_TYPE___ns1__FaceService; }
        /** Constructor with member initializations */
        __ns1__FaceService()
        {
          ns1__FaceService = (_ns1__FaceService *)0;
        }
        /** Friend allocator used by soap_new___ns1__FaceService(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__FaceService * SOAP_FMAC2 soap_instantiate___ns1__FaceService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* InterfaceToFace.h:851 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (69)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* InterfaceToFace.h:851 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (70)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* InterfaceToFace.h:851 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (72)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* InterfaceToFace.h:851 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (75)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* InterfaceToFace.h:851 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (76)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* InterfaceToFace.h:101 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* InterfaceToFace.h:101 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* InterfaceToFace.h:164 */
#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (19)
typedef char xsd__byte;
#endif

/* InterfaceToFace.h:167 */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (20)
typedef unsigned char xsd__unsignedByte;
#endif

/* InterfaceToFace.h:170 */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (22)
typedef std::wstring xsd__ID;
#endif

/* InterfaceToFace.h:180 */
#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (24)
typedef std::wstring xsd__IDREF;
#endif

/* InterfaceToFace.h:197 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (27)
typedef std::wstring xsd__anyURI;
#endif

/* InterfaceToFace.h:235 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (35)
typedef std::wstring xsd__decimal;
#endif

/* InterfaceToFace.h:252 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (39)
typedef std::wstring xsd__duration;
#endif

/* InterfaceToFace.h:364 */
#ifndef SOAP_TYPE_ns3__char
#define SOAP_TYPE_ns3__char (57)
typedef int ns3__char;
#endif

/* InterfaceToFace.h:377 */
#ifndef SOAP_TYPE_ns3__duration
#define SOAP_TYPE_ns3__duration (59)
typedef std::wstring ns3__duration;
#endif

/* InterfaceToFace.h:389 */
#ifndef SOAP_TYPE_ns3__guid
#define SOAP_TYPE_ns3__guid (61)
typedef std::wstring ns3__guid;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* xsd__byte has binding name 'xsd__byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (19)
#endif

/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* short has binding name 'short' for type 'xsd:short' */
#ifndef SOAP_TYPE_short
#define SOAP_TYPE_short (47)
#endif

/* ns3__char has binding name 'ns3__char' for type 'ns3:char' */
#ifndef SOAP_TYPE_ns3__char
#define SOAP_TYPE_ns3__char (57)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (45)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (42)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (38)
#endif

/* xsd__unsignedByte has binding name 'xsd__unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (20)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (17)
#endif

/* unsigned short has binding name 'unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_unsignedShort
#define SOAP_TYPE_unsignedShort (54)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (16)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (52)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (34)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (31)
#endif

/* ns3__guid__ has binding name 'ns3__guid__' for type 'ns3:guid' */
#ifndef SOAP_TYPE_ns3__guid__
#define SOAP_TYPE_ns3__guid__ (62)
#endif

/* ns3__guid has binding name 'ns3__guid' for type 'ns3:guid' */
#ifndef SOAP_TYPE_ns3__guid
#define SOAP_TYPE_ns3__guid (61)
#endif

/* ns3__duration__ has binding name 'ns3__duration__' for type 'ns3:duration' */
#ifndef SOAP_TYPE_ns3__duration__
#define SOAP_TYPE_ns3__duration__ (60)
#endif

/* ns3__duration has binding name 'ns3__duration' for type 'ns3:duration' */
#ifndef SOAP_TYPE_ns3__duration
#define SOAP_TYPE_ns3__duration (59)
#endif

/* ns3__char__ has binding name 'ns3__char__' for type 'ns3:char' */
#ifndef SOAP_TYPE_ns3__char__
#define SOAP_TYPE_ns3__char__ (58)
#endif

/* _ns1__FaceServiceResponse has binding name '_ns1__FaceServiceResponse' for type '' */
#ifndef SOAP_TYPE__ns1__FaceServiceResponse
#define SOAP_TYPE__ns1__FaceServiceResponse (56)
#endif

/* _ns1__FaceService has binding name '_ns1__FaceService' for type '' */
#ifndef SOAP_TYPE__ns1__FaceService
#define SOAP_TYPE__ns1__FaceService (55)
#endif

/* xsd__unsignedShort has binding name 'xsd__unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (53)
#endif

/* xsd__unsignedLong has binding name 'xsd__unsignedLong' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (51)
#endif

/* xsd__unsignedInt has binding name 'xsd__unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (50)
#endif

/* xsd__unsignedByte_ has binding name 'xsd__unsignedByte_' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte_
#define SOAP_TYPE_xsd__unsignedByte_ (49)
#endif

/* xsd__string has binding name 'xsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (48)
#endif

/* xsd__short has binding name 'xsd__short' for type 'xsd:short' */
#ifndef SOAP_TYPE_xsd__short
#define SOAP_TYPE_xsd__short (46)
#endif

/* xsd__long has binding name 'xsd__long' for type 'xsd:long' */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (44)
#endif

/* xsd__int has binding name 'xsd__int' for type 'xsd:int' */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (43)
#endif

/* xsd__float has binding name 'xsd__float' for type 'xsd:float' */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (41)
#endif

/* xsd__duration_ has binding name 'xsd__duration_' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (40)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (39)
#endif

/* xsd__double has binding name 'xsd__double' for type 'xsd:double' */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (37)
#endif

/* xsd__decimal_ has binding name 'xsd__decimal_' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal_
#define SOAP_TYPE_xsd__decimal_ (36)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (35)
#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (33)
#endif

/* xsd__byte_ has binding name 'xsd__byte_' for type 'xsd:byte' */
#ifndef SOAP_TYPE_xsd__byte_
#define SOAP_TYPE_xsd__byte_ (32)
#endif

/* xsd__boolean has binding name 'xsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (30)
#endif

/* xsd__base64Binary_ has binding name 'xsd__base64Binary_' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (29)
#endif

/* xsd__anyURI_ has binding name 'xsd__anyURI_' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (28)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (27)
#endif

/* xsd__QName_ has binding name 'xsd__QName_' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName_
#define SOAP_TYPE_xsd__QName_ (26)
#endif

/* xsd__IDREF_ has binding name 'xsd__IDREF_' for type 'xsd:IDREF' */
#ifndef SOAP_TYPE_xsd__IDREF_
#define SOAP_TYPE_xsd__IDREF_ (25)
#endif

/* xsd__IDREF has binding name 'xsd__IDREF' for type 'xsd:IDREF' */
#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (24)
#endif

/* xsd__ID_ has binding name 'xsd__ID_' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID_
#define SOAP_TYPE_xsd__ID_ (23)
#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (22)
#endif

/* std::wstring has binding name 'std__wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__wstring
#define SOAP_TYPE_std__wstring (21)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (15)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (14)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (13)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (11)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (76)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (75)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (72)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (70)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (69)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (78)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (77)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (71)
#endif

/* _ns1__FaceService * has binding name 'PointerTo_ns1__FaceService' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__FaceService
#define SOAP_TYPE_PointerTo_ns1__FaceService (65)
#endif

/* wchar_t * has binding name 'wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_wstring
#define SOAP_TYPE_wstring (64)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (18)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
